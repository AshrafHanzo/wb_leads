const express = require('express');
const cors = require('cors');
const { Pool } = require('pg');
require('dotenv').config();

const app = express();
const port = process.env.PORT || 3001;

// Middleware
app.use(cors());
app.use(express.json());

// Database connection
const pool = new Pool({
    host: process.env.DB_HOST || '103.14.123.44',
    port: process.env.DB_PORT || 30018,
    database: process.env.DB_NAME || 'wb_lead',
    user: process.env.DB_USER || 'dhi_admin',
    password: process.env.DB_PASSWORD || 'dhi@123',
});

// Test database connection and run migrations
pool.query('SELECT NOW()', async (err, res) => {
    if (err) {
        console.error('Error connecting to database:', err);
    } else {
        console.log('Database connected successfully');

        // Fix: Drop legacy check constraint that conflicts with dynamic master table
        try {
            await pool.query('ALTER TABLE leads DROP CONSTRAINT IF EXISTS leads_lead_source_check');
            console.log('Fixed: Dropped leads_lead_source_check constraint');
        } catch (e) {
            console.log('Note: Constraint might not exist or could not be dropped', e.message);
        }

        // Seed/Reset Admin User
        try {
            const adminEmail = 'jananimohan44@gmail.com';
            const adminPass = 'janani04';
            // Check if exists
            const userCheck = await pool.query('SELECT user_id FROM users WHERE email = $1', [adminEmail]);
            if (userCheck.rows.length > 0) {
                // Update password
                await pool.query('UPDATE users SET password = $1 WHERE email = $2', [adminPass, adminEmail]);
                console.log('Admin password reset successfully');
            } else {
                // Create user
                await pool.query(
                    "INSERT INTO users (full_name, email, password, role, status) VALUES ($1, $2, $3, 'Admin', 'Active')",
                    ['Janani Mohan', adminEmail, adminPass]
                );
                console.log('Admin user created successfully');
            }
        } catch (e) {
            console.error('Error seeding admin user:', e.message);
        }
    }
});

// API Routes

// Health Check
app.get('/health', async (req, res) => {
    try {
        const result = await pool.query('SELECT NOW()');
        res.json({ status: 'healthy', timestamp: result.rows[0].now });
    } catch (err) {
        res.status(500).json({ status: 'unhealthy', error: err.message });
    }
});

// Get Industries
app.get('/api/leads/industries', async (req, res) => {
    try {
        const result = await pool.query('SELECT industry_id, industry_name FROM industry_master ORDER BY industry_name');
        res.json(result.rows);
    } catch (err) {
        console.error('Error fetching industries:', err);
        res.status(500).json({ error: 'Internal server error' });
    }
});

// Get Lead Sources
app.get('/api/leads/lead-sources', async (req, res) => {
    try {
        const result = await pool.query('SELECT lead_source_id as source_id, lead_source_name as source_name FROM lead_source_master ORDER BY lead_source_name');
        res.json(result.rows);
    } catch (err) {
        console.error('Error fetching lead sources:', err);
        res.status(500).json({ error: 'Internal server error' });
    }
});

// Get Products (for dropdown or mapping)
app.get('/api/leads/products', async (req, res) => {
    try {
        // Try to query products_master table, if it doesn't exist return empty array
        const result = await pool.query('SELECT product_id, product_name FROM products_master ORDER BY product_name');
        res.json(result.rows);
    } catch (err) {
        // If table doesn't exist, return empty array instead of error
        if (err.code === '42P01') { // PostgreSQL error code for undefined table
            console.log('products_master table does not exist, returning empty array');
            res.json([]);
        } else {
            console.error('Error fetching products:', err);
            res.status(500).json({ error: 'Internal server error' });
        }
    }
});

// Get Users (for Generated By)
app.get('/api/leads/users', async (req, res) => {
    try {
        const result = await pool.query("SELECT user_id, full_name, role FROM users WHERE status = 'Active' ORDER BY full_name");
        res.json(result.rows);
    } catch (err) {
        console.error('Error fetching users:', err);
        res.status(500).json({ error: 'Internal server error' });
    }
});

// Get Stages
app.get('/api/leads/stages', async (req, res) => {
    try {
        const result = await pool.query('SELECT stage_id, stage_name FROM lead_stages ORDER BY stage_id');
        res.json(result.rows);
    } catch (err) {
        console.error('Error fetching stages:', err);
        res.status(500).json({ error: 'Internal server error' });
    }
});

// Get Statuses
app.get('/api/leads/statuses', async (req, res) => {
    try {
        const result = await pool.query('SELECT status_id, status_name, stage_id FROM lead_stage_status ORDER BY status_id');
        res.json(result.rows);
    } catch (err) {
        console.error('Error fetching statuses:', err);
        res.status(500).json({ error: 'Internal server error' });
    }
});

// Get Accounts (Dropdown)
app.get('/api/leads/accounts', async (req, res) => {
    try {
        const result = await pool.query('SELECT account_id, account_name FROM accounts ORDER BY account_name');
        res.json(result.rows);
    } catch (err) {
        console.error('Error fetching accounts:', err);
        res.status(500).json({ error: 'Internal server error' });
    }
});

// Get All Accounts (Full Details)
app.get('/api/accounts', async (req, res) => {
    try {
        const result = await pool.query('SELECT * FROM accounts ORDER BY created_date DESC');
        res.json(result.rows);
    } catch (err) {
        console.error('Error fetching all accounts:', err);
        res.status(500).json({ error: 'Internal server error' });
    }
});

// Create Account
app.post('/api/accounts', async (req, res) => {
    const client = await pool.connect();
    try {
        const {
            account_name, industry, head_office, location,
            primary_contact_name, contact_person_role, contact_phone,
            contact_email, company_phone, account_status, account_owner, remarks
        } = req.body;

        await client.query('BEGIN');

        // Check duplicate
        const check = await client.query('SELECT account_id FROM accounts WHERE account_name = $1', [account_name]);
        if (check.rows.length > 0) {
            await client.query('ROLLBACK');
            return res.status(400).json({ error: 'Account already exists' });
        }

        const result = await client.query(
            `INSERT INTO accounts (
                account_name, industry, head_office, location,
                primary_contact_name, contact_person_role, contact_phone,
                contact_email, company_phone, account_status, account_owner, remarks,
                created_date, last_updated
            ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, NOW(), NOW())
            RETURNING *`,
            [
                account_name, industry, head_office, location,
                primary_contact_name, contact_person_role, contact_phone,
                contact_email, company_phone, account_status || 'Prospect', account_owner, remarks
            ]
        );

        await client.query('COMMIT');
        res.json({ success: true, account: result.rows[0] });
    } catch (err) {
        await client.query('ROLLBACK');
        console.error('Create account error:', err);
        res.status(500).json({ error: 'Failed to create account' });
    } finally {
        client.release();
    }
});

// Update Account
app.put('/api/accounts/:id', async (req, res) => {
    const { id } = req.params;
    const client = await pool.connect();
    try {
        const {
            account_name, industry, head_office, location,
            primary_contact_name, contact_person_role, contact_phone,
            contact_email, company_phone, account_status, account_owner, remarks
        } = req.body;

        await client.query('BEGIN');

        const result = await client.query(
            `UPDATE accounts SET 
                account_name = $1, industry = $2, head_office = $3, location = $4,
                primary_contact_name = $5, contact_person_role = $6, contact_phone = $7,
                contact_email = $8, company_phone = $9, account_status = $10, 
                account_owner = $11, remarks = $12, last_updated = NOW()
            WHERE account_id = $13
            RETURNING *`,
            [
                account_name, industry, head_office, location,
                primary_contact_name, contact_person_role, contact_phone,
                contact_email, company_phone, account_status, account_owner, remarks,
                id
            ]
        );

        if (result.rows.length === 0) {
            await client.query('ROLLBACK');
            return res.status(404).json({ error: 'Account not found' });
        }

        await client.query('COMMIT');
        res.json({ success: true, account: result.rows[0] });
    } catch (err) {
        await client.query('ROLLBACK');
        console.error('Update account error:', err);
        res.status(500).json({ error: 'Failed to update account' });
    } finally {
        client.release();
    }
});

// Delete Account
app.delete('/api/accounts/:id', async (req, res) => {
    const { id } = req.params;
    try {
        // Check for dependencies (leads)
        const check = await pool.query('SELECT lead_id FROM leads WHERE account_id = $1 LIMIT 1', [id]);
        if (check.rows.length > 0) {
            return res.status(400).json({ error: 'Cannot delete account with existing leads' });
        }

        await pool.query('DELETE FROM accounts WHERE account_id = $1', [id]);
        res.json({ success: true, message: 'Account deleted' });
    } catch (err) {
        console.error('Delete account error:', err);
        res.status(500).json({ error: 'Failed to delete account' });
    }
});

// Get Dashboard Stats
app.get('/api/dashboard', async (req, res) => {
    try {
        const client = await pool.connect();
        try {
            // 1. Counts & Sums
            // Revenue: Sum of expected_value for leads in 'Closed Won' stage (assuming stage_id for Closed Won is known or joined)
            // Pipeline: Sum of expected_value for leads NOT in 'Closed Won' or 'Closed Lost'

            // We need to know stage IDs for Won/Lost. Let's assume joining on names is safer or fetching them first.
            // A single query with CTEs or subqueries is efficient.

            const statsQuery = `
                WITH StageCounts AS (
                    SELECT 
                        s.stage_name, 
                        COUNT(l.lead_id) as count,
                        COALESCE(SUM(l.expected_value), 0) as value
                    FROM lead_stages s
                    LEFT JOIN leads l ON s.stage_id = l.stage_id
                    GROUP BY s.stage_name
                ),
                Totals AS (
                    SELECT 
                        (SELECT COUNT(*) FROM leads) as total_leads,
                        (SELECT COUNT(*) FROM accounts) as total_accounts,
                        (SELECT COUNT(*) FROM leads WHERE next_followup_date::date = CURRENT_DATE) as today_followups
                )
                SELECT 
                    t.*,
                    (SELECT COALESCE(SUM(l.expected_value), 0) FROM leads l JOIN lead_stages s ON l.stage_id = s.stage_id WHERE s.stage_name = 'Closed Won') as total_revenue,
                    (SELECT COALESCE(SUM(l.expected_value), 0) FROM leads l JOIN lead_stages s ON l.stage_id = s.stage_id WHERE s.stage_name NOT IN ('Closed Won', 'Closed Lost')) as expected_pipeline
                FROM Totals t;
            `;

            const statsResult = await client.query(statsQuery);
            const stats = statsResult.rows[0];

            // 2. Leads by Stage (from the CTE logic effectively, or just query again for clean list)
            const stagesQuery = `
                SELECT s.stage_name as name, COUNT(l.lead_id)::int as count 
                FROM lead_stages s 
                LEFT JOIN leads l ON s.stage_id = l.stage_id 
                GROUP BY s.stage_id, s.stage_name 
                ORDER BY s.stage_id
            `;
            const stagesResult = await client.query(stagesQuery);

            // 3. Recent Leads
            const recentLeadsQuery = `
                 SELECT 
                    l.lead_id,
                    l.lead_date,
                    a.account_name,
                    u.full_name as generated_by_name,
                    l.lead_source,
                    s.stage_name,
                    l.expected_value
                FROM leads l
                LEFT JOIN accounts a ON l.account_id = a.account_id
                LEFT JOIN users u ON l.lead_generated_by = u.user_id
                LEFT JOIN lead_stages s ON l.stage_id = s.stage_id
                ORDER BY l.created_date DESC
                LIMIT 5
            `;
            const recentLeadsResult = await client.query(recentLeadsQuery);

            res.json({
                totalLeads: parseInt(stats.total_leads),
                totalAccounts: parseInt(stats.total_accounts),
                totalRevenue: parseFloat(stats.total_revenue),
                expectedPipeline: parseFloat(stats.expected_pipeline),
                todayFollowups: parseInt(stats.today_followups),
                leadsByStage: stagesResult.rows,
                recentLeads: recentLeadsResult.rows
            });

        } finally {
            client.release();
        }
    } catch (err) {
        console.error('Error fetching dashboard stats:', err);
        res.status(500).json({ error: 'Internal server error' });
    }
});

// Get All Leads (with joined details)
app.get('/api/leads', async (req, res) => {
    try {
        const query = `
            SELECT
                l.lead_id,
                l.lead_date,
                a.account_name,
                u.full_name as generated_by,
                ud.full_name as de_assigned_to_name,
                l.de_assigned_to,
                l.lead_source,
                l.stage_id,
                s.stage_name,
                l.status_id,
                st.status_name
            FROM leads l
            LEFT JOIN accounts a ON l.account_id = a.account_id
            LEFT JOIN users u ON l.lead_generated_by = u.user_id
            LEFT JOIN users ud ON l.de_assigned_to = ud.user_id
            LEFT JOIN lead_stages s ON l.stage_id = s.stage_id
            LEFT JOIN lead_stage_status st ON l.status_id = st.status_id
            ORDER BY l.created_date DESC
        `;
        const result = await pool.query(query);
        res.json(result.rows);
    } catch (err) {
        console.error('Error fetching leads:', err);
        res.status(500).json({ error: 'Internal server error' });
    }
});

// Get Single Lead (with full details for editing)
app.get('/api/leads/:id', async (req, res) => {
    try {
        const { id } = req.params;
        const query = `
            SELECT 
                l.*,
                a.account_name,
                a.industry,
                a.head_office,
                a.location,
                a.primary_contact_name,
                a.contact_person_role,
                a.contact_phone,
                a.contact_email,
                a.company_phone,
                u.full_name as generated_by_name,
                ud.full_name as de_assigned_to_name,
                s.stage_name,
                st.status_name
            FROM leads l
            LEFT JOIN accounts a ON l.account_id = a.account_id
            LEFT JOIN users u ON l.lead_generated_by = u.user_id
            LEFT JOIN users ud ON l.de_assigned_to = ud.user_id
            LEFT JOIN lead_stages s ON l.stage_id = s.stage_id
            LEFT JOIN lead_stage_status st ON l.status_id = st.status_id
            WHERE l.lead_id = $1
        `;
        const result = await pool.query(query, [id]);

        if (result.rows.length === 0) {
            return res.status(404).json({ error: 'Lead not found' });
        }

        res.json(result.rows[0]);
    } catch (err) {
        console.error('Error fetching lead:', err);
        res.status(500).json({ error: 'Internal server error' });
    }
});

// Update Lead (Transactional)
app.put('/api/leads/:id', async (req, res) => {
    const { id } = req.params;
    const {
        account_name,
        industry,
        head_office,
        location,
        company_website,
        primary_contact_name,
        contact_person_role,
        contact_phone,
        contact_email,
        company_phone,
        lead_source,
        lead_generated_by,
        stage_id,
        status_id
    } = req.body;

    const client = await pool.connect();

    try {
        await client.query('BEGIN');

        // 1. Get account_id from the lead
        const leadCheck = await client.query('SELECT account_id FROM leads WHERE lead_id = $1', [id]);
        if (leadCheck.rows.length === 0) {
            await client.query('ROLLBACK');
            return res.status(404).json({ error: 'Lead not found' });
        }
        const account_id = leadCheck.rows[0].account_id;

        // 2. Update Account
        await client.query(
            `UPDATE accounts SET
        account_name = $1,
            industry = $2,
            head_office = $3,
            location = $4,
            primary_contact_name = $5,
            contact_person_role = $6,
            contact_phone = $7,
            contact_email = $8,
            company_phone = $9
            WHERE account_id = $10`,
            [
                account_name,
                industry,
                head_office,
                location,
                primary_contact_name,
                contact_person_role,
                contact_phone,
                contact_email,
                company_phone,
                account_id
            ]
        );

        // 3. Update Lead
        await client.query(
            `UPDATE leads SET
        lead_source = $1,
            lead_generated_by = $2,
            stage_id = $3,
            status_id = $4
            WHERE lead_id = $5`,
            [lead_source, lead_generated_by, stage_id, status_id, id]
        );

        await client.query('COMMIT');

        res.json({
            success: true,
            message: 'Lead updated successfully'
        });
    } catch (error) {
        await client.query('ROLLBACK');
        console.error('Error updating lead:', error);
        res.status(500).json({ error: 'Failed to update lead', details: error.message });
    } finally {
        client.release();
    }
});

// Create Lead (Transactional)
app.post('/api/leads', async (req, res) => {
    const {
        account_name,
        industry,
        head_office,
        location,
        company_website, // kept for destructuring consistency
        primary_contact_name,
        contact_person_role,
        contact_phone,
        contact_email,
        company_phone,
        lead_source,
        lead_generated_by,
        stage_id,
        status_id
    } = req.body;

    const client = await pool.connect();

    try {
        await client.query('BEGIN');

        // First, insert or get account
        // Check if account exists
        const checkAccount = await client.query(
            'SELECT account_id FROM accounts WHERE account_name = $1',
            [account_name]
        );

        let account_id;

        if (checkAccount.rows.length > 0) {
            // Update existing account
            account_id = checkAccount.rows[0].account_id;
            await client.query(
                `UPDATE accounts SET
        industry = $2,
            head_office = $3,
            location = $4,
            primary_contact_name = $5,
            contact_person_role = $6,
            contact_phone = $7,
            contact_email = $8,
            company_phone = $9,
            last_updated = NOW()
                WHERE account_id = $1`,
                [account_id, industry, head_office, location,
                    primary_contact_name, contact_person_role, contact_phone,
                    contact_email, company_phone]
            );
        } else {
            // Insert new account
            // Fixed VALUES clause to match column count (removed extra $10)
            const insertAccount = await client.query(
                `INSERT INTO accounts(
                account_name, industry, head_office, location,
                primary_contact_name, contact_person_role, contact_phone,
                contact_email, company_phone, account_status, created_date, last_updated
            ) VALUES($1, $2, $3, $4, $5, $6, $7, $8, $9, 'Prospect', NOW(), NOW())
                RETURNING account_id`,
                [account_name, industry, head_office, location,
                    primary_contact_name, contact_person_role, contact_phone,
                    contact_email, company_phone]
            );
            account_id = insertAccount.rows[0].account_id;
        }

        // Then, insert the lead
        const leadResult = await client.query(
            `INSERT INTO leads(
                account_id, lead_date, lead_source, lead_generated_by,
                stage_id, status_id, created_date
            ) VALUES($1, NOW(), $2, $3, $4, $5, NOW())
            RETURNING lead_id`,
            [account_id, lead_source, lead_generated_by, stage_id, status_id]
        );

        await client.query('COMMIT');

        res.json({
            success: true,
            lead_id: leadResult.rows[0].lead_id,
            account_id: account_id,
            message: 'Lead created successfully'
        });
    } catch (error) {
        await client.query('ROLLBACK');
        console.error('Error creating lead:', error);
        res.status(500).json({ error: 'Failed to create lead', details: error.message });
    } finally {
        client.release();
    }
});

// Update Lead Stage/Status Only (Simple update without requiring all fields)
app.patch('/api/leads/:id/stage', async (req, res) => {
    const { id } = req.params;
    const { stage_id, status_id } = req.body;

    try {
        // Check if lead exists and get current values
        const leadCheck = await pool.query('SELECT lead_id, status_id FROM leads WHERE lead_id = $1', [id]);
        if (leadCheck.rows.length === 0) {
            return res.status(404).json({ error: 'Lead not found' });
        }

        // Use provided status_id or keep existing
        const finalStatusId = status_id !== undefined ? status_id : leadCheck.rows[0].status_id;

        // Update only stage and status
        await pool.query(
            `UPDATE leads SET stage_id = $1, status_id = $2 WHERE lead_id = $3`,
            [stage_id, finalStatusId, id]
        );

        res.json({
            success: true,
            message: 'Lead stage updated successfully'
        });
    } catch (error) {
        console.error('Error updating lead stage:', error);
        res.status(500).json({ error: 'Failed to update lead stage', details: error.message });
    }
});

// Update Lead DE Assignment
app.patch('/api/leads/:id/de-assignment', async (req, res) => {
    const { id } = req.params;
    const { de_assigned_to } = req.body;
    console.log('Update DE assigned:', { id, de_assigned_to });
    try {
        await pool.query(
            'UPDATE leads SET de_assigned_to = $1 WHERE lead_id = $2',
            [de_assigned_to, id]
        );
        res.json({ success: true });
    } catch (err) {
        console.error('Update DE assignment error:', err);
        res.status(500).json({ error: 'Failed to update DE assignment' });
    }
});

// Delete Lead
app.delete('/api/leads/:id', async (req, res) => {
    const { id } = req.params;
    const client = await pool.connect();

    try {
        await client.query('BEGIN');

        // Check if lead exists
        const checkLead = await client.query('SELECT account_id FROM leads WHERE lead_id = $1', [id]);
        if (checkLead.rows.length === 0) {
            await client.query('ROLLBACK');
            return res.status(404).json({ error: 'Lead not found' });
        }

        // Delete the lead
        await client.query('DELETE FROM leads WHERE lead_id = $1', [id]);

        await client.query('COMMIT');
        res.json({ success: true, message: 'Lead deleted successfully' });
    } catch (err) {
        await client.query('ROLLBACK');
        console.error('Error deleting lead:', err);
        res.status(500).json({ error: 'Internal server error' });
    } finally {
        client.release();
    }
});

// --- Auth & User Management Endpoints ---

// Login
// Login
app.post('/api/login', async (req, res) => {
    const { email, password } = req.body;
    console.log('Login Request:', email, password);

    try {
        // SUPER BYPASS: Check email (or username) and allow ANY password
        const cleanEmail = email.trim().toLowerCase();
        if (cleanEmail === 'jananimohan44@gmail.com' || cleanEmail === 'janani04') {
            console.log('Login: Using User Bypass');

            // Try to get real user from DB
            const result = await pool.query('SELECT * FROM users WHERE email = $1', ['jananimohan44@gmail.com']);
            if (result.rows.length > 0) {
                const user = result.rows[0];
                const { password: _, ...userWithoutPassword } = user;
                return res.json({ success: true, user: userWithoutPassword });
            } else {
                // FALLBACK: Return Mock Admin if DB fails
                console.log('Login: User not found in DB, returning MOCK Admin');
                return res.json({
                    success: true,
                    user: {
                        user_id: 1,
                        full_name: 'Janani Mohan (Rescue)',
                        email: 'jananimohan44@gmail.com',
                        role: 'Admin',
                        status: 'Active'
                    }
                });
            }
        }

        const result = await pool.query('SELECT * FROM users WHERE email = $1', [email]);
        if (result.rows.length === 0) {
            // Try case-insensitive fallback
            const fallback = await pool.query('SELECT * FROM users WHERE LOWER(email) = LOWER($1)', [email]);
            if (fallback.rows.length === 0) {
                // DEBUG INFO IN ERROR
                return res.status(401).json({ error: `Invalid email.Received: '${email}'` });
            }
            // Use fallback result
            const user = fallback.rows[0];
            if (user.password !== password) {
                return res.status(401).json({ error: `Invalid password.Received: '${password}'` });
            }
            const { password: _, ...userWithoutPassword } = user;
            return res.json({ success: true, user: userWithoutPassword });
        }

        const user = result.rows[0];
        if (user.password !== password) {
            return res.status(401).json({ error: `Invalid password.Expecting '${user.password}' vs '${password}'` });
        }

        // Return user info (excluding password)
        const { password: _, ...userWithoutPassword } = user;
        res.json({ success: true, user: userWithoutPassword });
    } catch (err) {
        console.error('Login error:', err);
        res.status(500).json({ error: 'Server error: ' + err.message });
    }
});

// Create User
app.post('/api/users', async (req, res) => {
    const { full_name, email, password, role, phone, status } = req.body;
    const client = await pool.connect();

    try {
        await client.query('BEGIN');

        // Check if email exists
        const check = await client.query('SELECT user_id FROM users WHERE email = $1', [email]);
        if (check.rows.length > 0) {
            await client.query('ROLLBACK');
            return res.status(400).json({ error: 'Email already exists' });
        }

        // Get new ID
        const maxId = await client.query('SELECT MAX(user_id) as max FROM users');
        const newId = (maxId.rows[0].max || 0) + 1;

        await client.query(
            'INSERT INTO users (user_id, full_name, email, password, role, phone, status, created_date) VALUES ($1, $2, $3, $4, $5, $6, $7, NOW())',
            [newId, full_name, email, password, role || 'Intern', phone, status || 'Active']
        );

        await client.query('COMMIT');
        res.json({ success: true, message: 'User created' });
    } catch (err) {
        await client.query('ROLLBACK');
        console.error('Create user error:', err);
        res.status(500).json({ error: 'Failed to create user' });
    } finally {
        client.release();
    }
});

// Update User
app.put('/api/users/:id', async (req, res) => {
    const { id } = req.params;
    const { full_name, email, role, phone, status, password } = req.body;

    try {
        let query = 'UPDATE users SET full_name = $1, email = $2, role = $3, phone = $4, status = $5';
        let params = [full_name, email, role, phone, status];

        if (password) {
            query += ', password = $6 WHERE user_id = $7';
            params.push(password, id);
        } else {
            query += ' WHERE user_id = $6';
            params.push(id);
        }

        await pool.query(query, params);
        res.json({ success: true, message: 'User updated' });
    } catch (err) {
        console.error('Update user error:', err);
        res.status(500).json({ error: 'Failed to update user' });
    }
});

// Delete User
app.delete('/api/users/:id', async (req, res) => {
    const { id } = req.params;
    try {
        await pool.query('DELETE FROM users WHERE user_id = $1', [id]);
        res.json({ success: true, message: 'User deleted' });
    } catch (err) {
        console.error('Delete user error:', err);
        res.status(500).json({ error: 'Failed to delete user' });
    }
});

// DEBUG: Manual Password Reset
app.get('/api/debug-reset', async (req, res) => {
    try {
        const adminEmail = 'jananimohan44@gmail.com';
        const adminPass = 'janani04';
        await pool.query('UPDATE users SET password = $1 WHERE email = $2', [adminPass, adminEmail]);
        res.json({ success: true, message: 'Admin password manually reset to janani04' });
    } catch (err) {
        res.status(500).json({ error: err.message });
    }
});

app.listen(port, '0.0.0.0', () => {
    console.log(`Server is running on http://0.0.0.0:${port}`);
    console.log(`API endpoints available at http://0.0.0.0:${port}/api/leads`);
    console.log(`Access from local machine: http://localhost:${port}`);
    console.log(`Access from network: http://<your-ip>:${port}`);
});
